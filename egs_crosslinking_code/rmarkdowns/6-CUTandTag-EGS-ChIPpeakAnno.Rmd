---
title: "8-CUTandTag-Chippeakanno"
output: html_document
date: "2024-07-15"
---
##Set up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load libraries}
library(ChIPseeker)
library(ChIPpeakAnno)
library(tidyverse)
library(rtracklayer)
library(AnnotationHub)
library(GenomicRanges)
#library(GenomicFeatures)
#library(org.Hs.eg.db)
library(paletteer)
library(clusterProfiler)
library(RColorBrewer)
library(msigdbr)
library(ggalluvial)
library(ComplexHeatmap)
#library(ggVennDiagram)
library(ggrepel)
library(ggsankey)
library(ggVennDiagram)
```

```{r Make Directories}
jobreport_dir <- file.path("job_reports")
diffbind_dir <- file.path("diffbind", "diffbind_results")
consensus_dir <- file.path("diffbind", "occupancy_results")
annotation_dir <- file.path("peak_annotations")
peak_dir <- file.path("peakCalling", "MACS3")
homer_dir <- file.path(annotation_dir, "homer_results")
figure_dir <- file.path("figures")

if(!dir.exists(annotation_dir)){
  dir.create(annotation_dir)
}

if(!dir.exists(homer_dir)){
  dir.create(homer_dir)
}
```




## Prepare annotation data

```{r Look for ensembl v111}
# Connect to annotation hub
ah <- AnnotationHub()

# Search for EnsDb objects that are homo sapiens
query(ah, c("Homo sapiens", "EnsDb"))

# Retrieve EnsDb
ensdb <- ah[["AH116291"]]

# Get granges of features
ensdb_granges <- genes(ensdb)

# Subset for protein coding genes only
ensdb_coding_granges <- ensdb_granges[ mcols(ensdb_granges)$gene_biotype == "protein_coding" ]
```


## Build Enhancer and CTCF Labels

```{r Read in consensus NTC peaks}
# Create GRangesList for each condition
granges_list <- list()

for(cond in c("_0nMEGS", "_200nMEGS", "_01pF")){
  
  # Initialize list to store peaks for this condition
  condition_peaks <- list()
  
  for(sample in list.files(path = peak_dir, pattern = paste0(cond, "-[A-Z]\\.macs3\\.nolambda_peaks\\.narrowPeak$"))){
    

    print(paste("Processing peak file:", sample))
    
    # Read the data first
    peaks_df <- read_delim(file = file.path(peak_dir, sample),
                           delim = "\t",
                           col_names = c("Chr", "Start", "End", "peak", "score", "strand"))

    # Convert to GRanges
    peaks <- makeGRangesFromDataFrame(peaks_df, keep.extra.columns = TRUE)
    
    # Store peaks with sample name as list element name
    sample_name <- gsub("\\.bed$", "", sample)  # Remove .bed extension
    condition_peaks[[sample_name]] <- peaks
    
  }
  
  # Convert to GRangesList and store in main list
  condition_name <- gsub("_", "", cond)  # Remove underscore for cleaner names
  granges_list[[condition_name]] <- GRangesList(condition_peaks)
}


names(granges_list$`200nMEGS`)
```




```{r Get overlaps of enhancer labeling histone marks}
# Get overlaps for H3K27ac, H3K27me3, H3K4me1, and CTCF
nox_overlaps <- findOverlapsOfPeaks(
                    granges_list$`0nMEGS`,
                    maxgap = 1000)

pf_overlaps <- findOverlapsOfPeaks(
                    granges_list$`01pF`,
                    maxgap = 1000
                    )

egs_overlaps <- findOverlapsOfPeaks(
                    granges_list$`200nMEGS`,
                    maxgap = 1000
                    )

makeVennDiagram(nox_overlaps)
makeVennDiagram(pf_overlaps)
makeVennDiagram(egs_overlaps)
```


```{r Save overlap venn diagrams}
capture.output({
  pdf("figures/EGS_CnT_PeakAnno_VennDiagram_0nMEGS-Overlaps.pdf")
  makeVennDiagram(nox_overlaps,
                    col = c("black"),
                    fill = c("#f5f5f5"),
                    cat = c("", "", "", ""),
                    main = "0nM EGS Peak Overlaps",
                    cex = 1.5,           # size of numbers in circles
                    cat.cex = 1.5,       # size of category labels
                    main.cex = 1.5)      # size of main title
  
  dev.off()
}, file = "/dev/null")

capture.output({
  pdf("figures/EGS_CnT_PeakAnno_VennDiagram_200nMEGS-Overlaps.pdf")
  makeVennDiagram(egs_overlaps,
                    col = c("#ed2024"),
                    fill = c("#fce1e1"),
                    cat = c("", "", "", ""),
                    main = "200nM EGS Peak Overlaps",
                    cex = 1.5,           # size of numbers in circles
                    cat.cex = 1.5,       # size of category labels
                    main.cex = 1.5)      # size of main title
  
  dev.off()
}, file = "/dev/null")


capture.output({
  pdf("figures/EGS_CnT_PeakAnno_VennDiagram_01pF-Overlaps.pdf")
  makeVennDiagram(pf_overlaps,
                    col = c("#4e69b1"),
                    fill = c("#dce5fc"),
                    cat = c("", "", "", ""),
                    main = "1% CH2O EGS Peak Overlaps",
                    cex = 1.5,           # size of numbers in circles
                    cat.cex = 1.5,       # size of category labels
                    main.cex = 1.5)      # size of main title
  
  dev.off()
}, file = "/dev/null")
```


Active enhancers with CTCF binding are an important subset identified by Ren et al Molecular Cell 2017
```{r read in conensus peaks}
nox_consensus <- read_delim(file = file.path(consensus_dir, "0nMEGS_CTCF_consensus.macs3.bed"),
                            delim = "\t",
                            col_names = c("Chr", "Start", "End", "peakID", "conc_NTC")) %>%
                              makeGRangesFromDataFrame(keep.extra.columns = TRUE)

egs_consensus <- read_delim(file = file.path(consensus_dir, "200nMEGS_CTCF_consensus.macs3.bed"),
                            delim = "\t",
                            col_names = c("Chr", "Start", "End", "peakID", "conc_NTC")) %>%
                              makeGRangesFromDataFrame(keep.extra.columns = TRUE)


pf_consensus <- read_delim(file = file.path(consensus_dir, "01pF_CTCF_consensus.macs3.bed"),
                            delim = "\t",
                            col_names = c("Chr", "Start", "End", "peakID", "conc_NTC", "strand")) %>%
                              makeGRangesFromDataFrame(keep.extra.columns = TRUE)

consensus_overlaps <- findOverlapsOfPeaks(
                      nox_consensus,
                      egs_consensus,
                      pf_consensus,
                      maxgap = 1000
                      )

makeVennDiagram(consensus_overlaps)
```


```{r}
capture.output({
  pdf("figures/EGS_CnT_PeakAnno_VennDiagram_Consensus-Overlaps.pdf")
  makeVennDiagram(consensus_overlaps,
                    col = c("black", "#ed2024", "#4e69b1"),
                    fill = c("#d9d9d9", "#fce1e1", "#dce5fc"),
                    main = "0nM EGS Peak Overlaps",
                    cex = 1.5,           # size of numbers in circles
                    cat.cex = 1.5,       # size of category labels
                    main.cex = 1.5)      # size of main title
  
  dev.off()
}, file = "/dev/null")
```



## Annotate Labeled Enhancers

```{r Add annotations using ChIPseeker}
enhancers_glist_anno <- lapply(enhancers_glist, 
                               annotatePeak,
                               TxDb = ensdb,
                               level = "gene",
                               annoDb = "org.Hs.eg.db",
                               tssRegion = c(-2000, 250),
                               genomicAnnotationPriority = c("Intergenic", "Promoter", "Intron", "Downstream",
                                                             "5UTR", "3UTR", "Exon"))

table(enhancers_glist_anno$Specified@anno$geneBiotype)

plotAnnoBar(enhancers_glist_anno)
plotDistToTSS(enhancers_glist_anno)
```



```{r Filter Annotated Enhancers and Get CTCF Overlaps}

# Get enhancers that didn't overlap the promoters of protein coding genes
enhancers_glist_anno <- lapply(names(enhancers_glist_anno), function(name){
  
  gr <- slot(enhancers_glist_anno[[name]], "anno")
  
  # Dont remove promoters from CTCF annotations
  if (name != "Solitary-CTCF" & name != "Active-CTCF-Enhancer") {
    
    # get granges from anno slot of s4  
    gr <- gr  %>%
      # subset based on biotype and annotation
      subset(!(geneBiotype == "protein_coding" & grepl("Promoter", annotation)))
  }
  
  # return the filtered and annotated granges
  return(gr)
  
})

# Add names back to annotated granges list
names(enhancers_glist_anno) <- c("Solitary-CTCF", "Specified-Enhancer", "Poised-Enhancer",
                            "Active-Enhancer", "Active-CTCF-Enhancer")

# Summarize filtered granges
lengths(enhancers_glist_anno)
```





```{r Plot distribution of enhancers and save bed files}

enhancer_df_anno <- data.frame()

for (en in names(enhancers_glist_anno)) {
  
  # Create dataframe fromg granges
  df <- enhancers_glist_anno[[en]] %>% data.frame()
  
  # Join dataframes for each enhancer type
  enhancer_df_anno <- df %>%
    mutate(enhancer_type = en, # add enhancer label
           annotated_location = case_when(
             annotation == "Distal Intergenic" ~ "Distal_Intergenic",
             grepl("Promoter", annotation) & 
               geneBiotype == "protein_coding" ~ annotation, #Keep promoter distance labels for proteind coding genes
             grepl("RNA|pseudo|LRG|TEC||TR_|IG_|artifact", geneBiotype) ~ "Intergenic",
             grepl("Intron", annotation) &
               geneBiotype == "protein_coding" ~ "Intronic",
             .default = annotation
           )) %>%
    rbind(., enhancer_df_anno)
  
  # Save bed files of enhancers with annotated labels
  df %>%
    # Select columns
    dplyr::select(seqnames, start, end, annotation, distanceToTSS, strand) %>%
    write.table(file = file.path(annotation_dir, paste0(en, "_Enhancers.bed")),
                sep = "\t",
                quote = FALSE,
                row.names = FALSE,
                col.names = FALSE)
}
  
enhancer_df_anno$enhancer_type <- factor(enhancer_df_anno$enhancer_type,
                                         levels = c("Solitary-CTCF", "Specified-Enhancer", "Poised-Enhancer",
                                                    "Active-CTCF-Enhancer", "Active-Enhancer"))



enhancer_fig <- enhancer_df_anno %>%
  dplyr::group_by(enhancer_type) %>%
  dplyr::count(annotated_location) %>%
  ggplot(aes(x=enhancer_type, y=n, fill = annotated_location)) +
  scale_fill_brewer(palette = "Set2") +
  geom_bar(position = "fill", stat = "identity") +
  theme_classic() +
  labs(title = "Genomic Locations of Enhancers", 
       x = "", y = "Percentage (%)", fill = "ENSEMBL Annotation") +
  #coord_flip() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1)) 
  

# Get counts by group and create custom annotation data frame
annotation_data <- enhancer_df_anno %>%
  group_by(enhancer_type) %>%
  summarize(count = n(), .groups = "drop") %>%
  mutate(
    y = 1.05,
    x = as.numeric(factor(enhancer_type, 
                         levels = c("Solitary-CTCF", "Specified-Enhancer", "Poised-Enhancer",
                                    "Active-CTCF-Enhancer", "Active-Enhancer")))
  )

# Add the custom annotations
enhancer_fig <- enhancer_fig + 
  geom_text(
    data = annotation_data,
    aes(x = x, y = y, label = count),
    inherit.aes = FALSE
  )


enhancer_fig2 <- enhancer_df_anno %>%
  count(enhancer_type) %>%
  ggplot(aes(x="Annotation", y=n, fill = enhancer_type)) +
  geom_bar(stat = "identity") +
  theme_classic() +
  labs(title = "Enhancer Annotations", x="", y="Count")

enhancer_fig
enhancer_fig2
```


```{r Save plot of annotations}
ggsave(filename = "figures/OCIAML3_CnT-Rx_PeakAnno_StackedBar_AnnotatedEnhancers_Position.pdf",
       enhancer_fig,
       width = 4.5,
       height = 3)

ggsave(filename = "figures/OCIAML3_CnT-Rx_PeakAnno_StackedBar_AnnotatedEnhancers_Count.pdf",
       enhancer_fig2,
       width = 3.5,
       height = 3)
```


## Homer

```{r Create bed files for high confidence DBRs}
# Get subsets of consensus DBRs
consensus_granges <- GRangesList( # Peaks only in no crosslinking
                                  consensus_overlaps$peaklist$nox_consensus,
                                  # Peaks only in 1% Form
                                  consensus_overlaps$peaklist$pf_consensus,
                                  # Peaks only in 0.2mM EGS
                                  consensus_overlaps$peaklist$egs_consensus,
                                  # High Confidence Consensus
                                  consensus_overlaps$peaklist$`nox_consensus///egs_consensus///pf_consensus`)

names(consensus_granges) <- c("0nmEGS", "01pF", "200nMEGS", "High-Confidence")




# Save each consensus type as a bed file
for(lab in c("0nmEGS", "01pF", "200nMEGS", "High-Confidence")){
  
  # Subset granges based on enhancer overlap
  df <- consensus_granges[[lab]] %>% data.frame() %>%
          dplyr::mutate(peakNames=lab) %>%
          dplyr::select(1:5)
  
  # Create output filename with directory path
  output_file <- file.path(homer_dir, paste0("CTCF_", lab, "_consensus.bed"))
    
  # Make bed file
  write.table(df,
              file = output_file,
              sep = "\t",
              quote = FALSE,
              row.names = FALSE,
              col.names = FALSE)
    
  message(paste("Exported:", output_file, "with", nrow(df), "rows"))
}
```



```{cat Create HOMER Script for DiffBind, engine.opts = list(file = 'scripts/11-Homer.sh')}
#!/bin/bash

#SBATCH -p normal # partition name
#SBATCH --job-name=DiffBindHOMER # Job name
#SBATCH --ntasks=1 # number of tasks
#SBATCH --time 0-10:00 # time limit (day-hour:min)
#SBATCH --cpus-per-task=30 # number of threads
#SBATCH --mem-per-cpu=7Gb # requested memory
#SBATCH --account=srrao # PI's net ID
#SBATCH -o job_reports/%x.out # File to which standard outpout will be written
#SBATCH -e job_reports/%x.err # File to which standard error wil be written
#SBATCH --mail-type=ALL # What email updates to send
#SBATCH --mail-user=jmurray@mcw.edu # Email adress to send to
echo Starting at $(date)
echo Job name: ${SLURM_JOB_NAME}, Job ID: ${SLURM_JOB_ID}
echo I have ${SLURM_CPUS_ON_NODE} CPUs on compute node $(hostname -s)

# Load modules
module load homer
module load parallel

# Set directory paths
projPath="/scratch/g/srrao/josiah_ociaml3/EGSx_CUTnTag"
bedPath="${projPath}/peak_annotations/homer_results"
homerPath="${projPath}/peak_annotations/homer_results"
refPath="${projPath}/ref_genomes/Homo_sapiens.GRCh38.dna.primary_assembly.fa"

mkdir -p "${homerPath}/wholeGenomeBg"

# Create function for parallelization of motif analysis
motif_calling(){
  local i=$1
  
  # Create output directories
  mkdir -p "${homerPath}/wholeGenomeBg/$i"
  
  # Find motifs using whole genome as background
  findMotifsGenome.pl \
  "$i".bed \
  "${refPath}" \
  "${homerPath}/wholeGenomeBg/$i/" \
  -size 400 -p 6
}


# Export all necessary variables
export -f motif_calling
export refPath homerPath

# Go to diffbind bed path
cd ${bedPath}

# parallel processing 5 jobs using 6 threads each (total of 30 threads)
ls *consensus.bed | cut -d . -f 1 | parallel -j 5 motif_calling {}

```

```{bash Run DiffBind Homer Analysis, engine.opts='-l'}
sbatch scripts/11-HOMER.sh
```

